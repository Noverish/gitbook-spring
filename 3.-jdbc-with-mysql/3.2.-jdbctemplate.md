# 3.2. JdbcTemplate

## 1\) CRUD

```java
// Select Many Rows
List<Map<String, Object>> results = jdbcTemplate.queryForList("SELECT * FROM table");

// Select One Row
Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM table");

// Select Scalar value
int count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM table", Integer.class);

// Insert
int insertedRows = jdbcTemplate.update("INSERT INTO test (id, title) VALUES (1, 'title')");

// Update
int updatedRows = jdbcTemplate.update("UPDATE test SET title='title2' WHERE id=1");

// Delete
int deletedRows = jdbcTemplate.update("DELETE FROM test WHERE id=1");
```

## 2\) Use Variable

```java
jdbcTemplate.queryForList("SELECT * FROM table WHERE id = ?", 1);
```

쿼리문에 ?로 PlaceHolder를 지정해놓고 바인딩될 변수를 위와 같은 방법으로 동적으로 넘겨줄 수 있습다. 이러한 방법은 위에서 한 모든 CRUD에 적용할 수 있습니다. 자세한 사용 방법은 [문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)를 참고해주세요.

## 3\) NamedParameterJdbcTemplate

```java
String sql = "SELECT * FROM table WHERE id = :id";

Map<String, Object> params = new HashMap<>();
params.put("id", 1);

namedParameterJdbcTemplate.queryForList(sql, params)
```

NamedParameterJdbcTemplate를 이용하면 `:변수명` 형태로 PlaceHolder를 지정할 수 있습니다. 변수를 순서가 아닌 이름으로 넘겨줄 수 있다는 큰 장점이 있습니다. 이러한 방법은 위에서 한 모든 CRUD에 적용할 수 있습니다. 자세한 사용 방법은 [문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.html)를 참고해주세요.

## 4\) POJO

```java
public class DemoData {
    private int id;
    private String name;
    
    public DemoData() {}
    
    public void setId(int id) {
        this.id = id;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public class DemoDataRowMapper implements RowMapper<DemoData> {
    @Override
    public DemoData mapRow(ResultSet rs, int rowNum) throws SQLException {
        DemoData d = new DemoData();
        d.setId(rs.getInt("id"));
        d.setName(rs.getString("name"));
        return d;
    }
}
```

```java
List<DemoData> results = jdbcTemplate.query("SELECT * FROM table", new DemoDataRowMapper());
```

RowMapper 인터페이스를 구현함으로써 query의 결과값을 POJO로 받을 수 있습니다.

### Java 8 Lambda

```java
List<DemoData> results = jdbcTemplate.query("SELECT * FROM table", (rs, rowNum) -> {
    DemoData d = new DemoData();
    d.setId(rs.getInt("id"));
    d.setName(rs.getString("name"));
    return d;
});
```

Java 8의 Lambda를 이용하여 RowMapper 인터페이스를 구현하지 않고 Mapping을 할 수 있습니다.

### BeanPropertyRowMapper

```java
RowMapper<DemoData> rowMapper = new BeanPropertyRowMapper<>(DemoData.class);
List<DemoData> results = jdbcTemplate.query("SELECT * FROM table", rowMapper);
```

POJO의 Property 이름과 Table Column 이름이 동일하다면 따로 RowMapper를 구현하지 않고 BeanPropertyRowMapper를 사용하면 자동으로 매핑해줍니다. 단 여기는 다음과 같은 제약사항이 따릅니다.

* Table Column 이름은 snake\_case로, POJO의 Property 이름은 camelCase로 되어있어야 합니다.
* POJO에는 인수가 없는 생성자와 모든 Property에 대한 setter 메서드가 존재해야 합니다.
* String, int, double, java.util.Date 등 Java 기본 데이터 타입만 지원합니다.

### ResultSetExtractor

RowMapper는 각각의 Row마다 매핑 메서드가 실행되는 반면 ResultSetExtractor는 직접 ResultSet을 순회하면서 List를 만든 후 반환합니다. 자세한 정보는 다른 곳을 찾아보세요.

### RowCallbackHandler

RowMapper는 Object를, ResultSetExtractor는 List&lt;Object&gt;를 반환하는 반면 RowCallbackHandler는 메서드 내에서 ResultSet를 처리한 후 아무 것도 반환하지 않습니다. 자세한 정보는 다른 곳을 찾아보세요.

## 5\) 기타

### batchUpdate

batchUpdate 메서를 사용하면 많은 양의 SQL 구문을 한 번에 처리할 수 있습니다.

### execute

execute 메서드를 사용하면 DDL 구문을 처리할 수 있습니다.

